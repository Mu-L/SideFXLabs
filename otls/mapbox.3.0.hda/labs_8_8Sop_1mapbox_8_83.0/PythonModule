import os 
import time 
import platform
import ssl
import warnings

from hutil.Qt import QtWidgets, QtWebEngineWidgets
from math import pi, sqrt, radians, sin, cos, tan, atan, degrees

try:
    from urllib.error import HTTPError
    from urllib.request import urlopen
except:
    from urllib2 import urlopen, HTTPError

import mercantile
# https://github.com/mapbox/mercantile/blob/main/mercantile/__init__.py
# mercantile.tile(lon=float, lat=float, zoom=int) returns Tile(x=int, y=int, z=int)
# mercantile.Tile(x=int, y=int, z=int) returns Tile(x=int, y=int, z=int)


def printError(message, should_add_new_line=True, should_raise_error=False):

    if should_add_new_line:
        print (message + '\n')
    else:
        print (message)
    
    if should_raise_error:
        raise hou.NodeError(message)

    return


def isIncludingColor(node):

    return node.parm('maps').evalAsInt() % 2 >= 1


def isIncludingElevation(node):

    return node.parm('maps').evalAsInt() % 4 >= 2


def disableAllColors(node):

    # Turns off heightfield material
    node.parm('addmat_hf').deleteAllKeyframes()
    node.parm('addmat_hf').set(0)
    node.parm('enablemat_hf').deleteAllKeyframes()
    node.parm('enablemat_hf').set(0)
    # Turns off mesh material
    node.parm('addmat_mesh').deleteAllKeyframes()
    node.parm('addmat_mesh').set(0)
    node.parm('enablemat_mesh').deleteAllKeyframes()
    node.parm('enablemat_mesh').set(0)
    # Turns off point color sampling
    node.parm('addcolor').deleteAllKeyframes()
    node.parm('addcolor').set(0)

    return


def updateMapSelection(node):

    if not isIncludingColor(node):
        disableAllColors(node)

    return


def refreshViewport(node):

    success = True

    if isIncludingElevation(node) and not os.path.exists(node.parm('filepath_elev').evalAsString()):
        success = False
        msg = "Elevation Map does not exist on disk."
        printError(msg)

    if isIncludingColor(node) and not os.path.exists(node.parm('filepath_color').evalAsString()):
        success = False
        msg = "Color Map does not exist on disk."
        printError(msg)

    if isIncludingColor(node) and node.parm('enabletiling').evalAsInt() and node.parm('usetileablecmap').evalAsInt():
        if not os.path.exists(node.parm('filepath_colort').evalAsString()):
            success = False
            msg = "The material needs Tileable Color Map (Seamless Tiling > Tileable Material), " \
                "but it does not exist on disk. Please render it when all the neighbours' Color Maps are available."
            printError(msg)

    if success:
        hou.hscript('glcache -r')

    return


def reloadTextures(node):

    success = True

    if isIncludingElevation(node) and not os.path.exists(node.parm('filepath_elev').evalAsString()):
        success = False
        msg = "Elevation Map does not exist on disk."
        printError(msg)

    if isIncludingColor(node) and not os.path.exists(node.parm('filepath_color').evalAsString()):
        success = False
        msg = "Color Map does not exist on disk."
        printError(msg)

    if isIncludingColor(node) and node.parm('enabletiling').evalAsInt() and node.parm('usetileablecmap').evalAsInt():
        if not os.path.exists(node.parm('filepath_colort').evalAsString()):
            success = False
            msg = "The material needs Tileable Color Map (Seamless Tiling > Tileable Material), " \
                "but it does not exist on disk. Please render it when all the neighbours' Color Maps are available."
            printError(msg)

    if success:
        hou.hscript('texcache -n')
        hou.hscript('glcache -c')
        node.node('cop_color/map_msg').parm('reload').pressButton()
        node.node('cop_elevation/map_msg').parm('reload').pressButton()
        node.node('mesh_Cd').parm('reload').pressButton()

    return


def checkHFMaterial(node):

    success = True

    if node.parm('addmat_hf').evalAsInt():
        # If heightfield material is to be used:

        should_enable = 1
    
        if node.parm('enabletiling').evalAsInt() and node.parm('usetileablecmap').evalAsInt():
            # If tileable color map is to be used:
            if not os.path.exists(node.parm('filepath_colort').evalAsString()):
                success = False
                should_enable = 0
                msg = "The heightfield material needs Tileable Color Map (Seamless Tiling > Tileable Material), " \
                    "but it does not exist on disk. Please render it when all the neighbours' Color Maps are available."
                printError(msg)

        else:
            # If color map is to be used:
            if not os.path.exists(node.parm('filepath_color').evalAsString()):
                success = False
                should_enable = 0
                msg = "The heightfield material needs Color Map, but it does not exist on disk."
                printError(msg)

        node.parm('addmat_hf').deleteAllKeyframes()
        node.parm('addmat_hf').set(should_enable)
        node.parm('enablemat_hf').deleteAllKeyframes()
        node.parm('enablemat_hf').set(should_enable)

    else:
        # If heightfield material is not to be used:

        node.parm('enablemat_hf').deleteAllKeyframes()
        node.parm('enablemat_hf').set(0)

    if success:
        hou.hscript('glcache -r')

    return


def checkMeshMaterial(node):

    success = True

    if node.parm('addmat_mesh').evalAsInt():
        # If mesh material is to be used:

        should_enable = 1
    
        if node.parm('enabletiling').evalAsInt() and node.parm('usetileablecmap').evalAsInt():
            # If tileable color map is to be used:
            if not os.path.exists(node.parm('filepath_colort').evalAsString()):
                success = False
                should_enable = 0
                msg = "The mesh material needs Tileable Color Map (Seamless Tiling > Tileable Material), " \
                    "but it does not exist on disk. Please render it when all the neighbours' Color Maps are available."
                printError(msg)

        else:
            # If color map is to be used:
            if not os.path.exists(node.parm('filepath_color').evalAsString()):
                success = False
                should_enable = 0
                msg = "The mesh material needs Color Map, but it does not exist on disk."
                printError(msg)

        node.parm('addmat_mesh').deleteAllKeyframes()
        node.parm('addmat_mesh').set(should_enable)
        node.parm('enablemat_mesh').deleteAllKeyframes()
        node.parm('enablemat_mesh').set(should_enable)

    else:
        # If mesh material is not to be used:

        node.parm('enablemat_mesh').deleteAllKeyframes()
        node.parm('enablemat_mesh').set(0)

    if success:
        hou.hscript('glcache -r')

    return


def checkMaterials(node):

    if isIncludingColor(node):
        checkHFMaterial(node)
        checkMeshMaterial(node)

    return


def checkPointColor(node):

    if isIncludingColor(node) and node.parm('addcolor').evalAsInt():
        # If terrain mesh is to sample point colors:

        if not os.path.exists(node.parm('filepath_color').evalAsString()):
            node.parm('addcolor').deleteAllKeyframes()
            node.parm('addcolor').set(0)
            msg = "Color Map does not exist on disk."
            printError(msg)

        else:
            node.node('mesh_Cd').parm('reload').pressButton()

    return


def hasColorMap(node, node_path):

    if type(node) is not hou.SopNode or node.type().nameComponents()[2] != 'mapbox':
        # If the node is not a valid Mapbox SOP:

        msg = "\"{0}\" does not point to a valid Mapbox SOP.".format(node_path)
        printError(msg)
        return False

    else:
        # If the node is a valid Mapbox SOP:

        node.node('cop_color/map_msg').parm('reload').pressButton()

        if not os.path.exists(node.parm('filepath_color').evalAsString()):
            msg = node.path() + "'s Color Map does not exist on disk."
            printError(msg)
            return False

    return True


def hasElevationMap(node, node_path):

    if type(node) is not hou.SopNode or node.type().nameComponents()[2] != 'mapbox':
        # If the node is not a valid Mapbox SOP:

        msg = "\"{0}\" does not point to a valid Mapbox SOP.".format(node_path)
        printError(msg)
        return False

    else:
        # If the node is a valid Mapbox SOP:

        node.node('cop_elevation/map_msg').parm('reload').pressButton()

        if not os.path.exists(node.parm('filepath_elev').evalAsString()):
            msg = node.path() + "'s Elevation Map does not exist on disk."
            printError(msg)
            return False

    return True


def allNeighbourColorMapsExist(node):

    success = True

    node.node('cop_color/map_msg').parm('reload').pressButton()

    if not os.path.exists(node.parm('filepath_color').evalAsString()):
        success = False
        msg = "Color Map does not exist on disk."
        printError(msg)

    if node.parm('enablenb_t').evalAsInt():
        parm = node.parm('mapboxsop_t')
        path = parm.evalAsString()
        if len(path.replace(' ', '')) > 0:
            mapbox_sop = node.node(path)
            success = hasColorMap(mapbox_sop, path) and success

    if node.parm('enablenb_r').evalAsInt():
        parm = node.parm('mapboxsop_r')
        path = parm.evalAsString()
        if len(path.replace(' ', '')) > 0:
            mapbox_sop = node.node(path)
            success = hasColorMap(mapbox_sop, path) and success

    if node.parm('enablenb_c').evalAsInt():
        parm = node.parm('mapboxsop_c')
        path = parm.evalAsString()
        if len(path.replace(' ', '')) > 0:
            mapbox_sop = node.node(path)
            success = hasColorMap(mapbox_sop, path) and success

    return success


def allNeighbourElevationMapsExist(node):

    success = True

    node.node('cop_elevation/map_msg').parm('reload').pressButton()

    if not os.path.exists(node.parm('filepath_elev').evalAsString()):
        success = False
        msg = "Elevation Map does not exist on disk."
        printError(msg)

    if node.parm('enablenb_t').evalAsInt():
        parm = node.parm('mapboxsop_t')
        path = parm.evalAsString()
        if len(path.replace(' ', '')) > 0:
            mapbox_sop = node.node(path)
            success = hasElevationMap(mapbox_sop, path) and success

    if node.parm('enablenb_r').evalAsInt():
        parm = node.parm('mapboxsop_r')
        path = parm.evalAsString()
        if len(path.replace(' ', '')) > 0:
            mapbox_sop = node.node(path)
            success = hasElevationMap(mapbox_sop, path) and success

    if node.parm('enablenb_c').evalAsInt():
        parm = node.parm('mapboxsop_c')
        path = parm.evalAsString()
        if len(path.replace(' ', '')) > 0:
            mapbox_sop = node.node(path)
            success = hasElevationMap(mapbox_sop, path) and success

    return success


def reloadNeighbourColorMaps(node):

    if allNeighbourColorMapsExist(node):
        hou.hscript("glcache -r")
    else:
        raise hou.NodeError("Tiling Error: See Houdini Console for more information.")

    return


def reloadNeighbourElevationMaps(node):

    if allNeighbourElevationMapsExist(node):
        hou.hscript("glcache -r")
    else:
        raise hou.NodeError("Tiling Error: See Houdini Console for more information.")

    return


def renderTileableColorMap(node):

    if allNeighbourColorMapsExist(node):
        node.node('cop_color/RENDER').render()
        hou.hscript("glcache -r")
    else:
        raise hou.NodeError("Tiling Error: See Houdini Console for more information.")

    return


def getAPIAccessToken(node):

    access_token = os.getenv("MAPBOX_API")
    if not access_token:
        access_token = node.parm("accesstoken").evalAsString()
    if access_token == '':
        msg = "API Access Token is required. Please follow the instructions on the Help page to set API Access Token."
        printError(msg, should_raise_error=True)

    return access_token


def getSKUToken(node):

    sku_token = node.parm('skutoken').evalAsString()
    if sku_token == '' and isIncludingElevation(node):
        msg = "SKU Token is required for downloading elevation maps. Please follow the instructions on the Help page to set SKU Token."
        printError(msg, should_raise_error=True)

    return sku_token


def onButtonSKU(node, web_view, window):

    url = web_view.url().toString()
    post_hashtag = url.split("#")
    if len(post_hashtag) == 1:
        return
    
    try:
        access_token, sku = post_hashtag[1].split(",")
        node.parm('skutoken').deleteAllKeyframes()
        node.parm('skutoken').set(sku)
        window.close()
        msg = "A new SKU Token is successfully acquired: {0}.".format(sku)
        printError(msg)

    except:
        msg = "Failed to acquire a new SKU Token.\nPlease wait a few seconds before pressing Get New SKU Token again."
        printError(msg, should_raise_error=True)

    return


def onButton(node, web_view, window, should_download):

    url = web_view.url().toString()
    post_hashtag = url.split("#")
    if len(post_hashtag) == 1:
        return

    if isIncludingElevation(node) and node.parm('skutoken').evalAsString() == '':
        # If a new SKU token is required:

        try:
            lon, lat, zoom, bound_N, bound_E, bound_S, bound_W, sku = post_hashtag[1].split(",")
            node.parm('skutoken').deleteAllKeyframes()
            node.parm('skutoken').set(sku)
            msg = "A new SKU Token is successfully acquired: {0}.".format(sku)
            printError(msg)

        except:
            # Occasionally, a SKU token is not appended to the URL for some unknown reason.
            # This is an acceptable fallback as getSKUToken() will report a warning.
            lon, lat, zoom, bound_N, bound_E, bound_S, bound_W = post_hashtag[1].split(",")

    else:
        # A new SKU token is not required:

        try:
            lon, lat, zoom, bound_N, bound_E, bound_S, bound_W = post_hashtag[1].split(",")
        except:
            # When setting a new SKU token with the interactive map buttons, it is possible 
            # to encounter an error after the new SKU token has been set. A common error can 
            # be "zoom level out of range". The map window will not close when an error occurs. 
            # Pressing any button again will return a URL that still contains a SKU substring.
            lon, lat, zoom, bound_N, bound_E, bound_S, bound_W, sku = post_hashtag[1].split(",")

    # Converts URL strings to floats
    lon = float(lon)
    lat = float(lat)
    zoom = float(zoom)

    if zoom <= 0.0:
        lon = lat = zoom = 0.0

    # Guarantees longitude is in the right range
    if abs(lon) > 360:
        lon %= 360
    if lon > 180 and lon <= 360:
        lon -= 360
    elif lon < -180 and lon >= -360:
        lon += 360

    # Stores location as node parameters
    if node.parm('locmode').evalAsInt() == 0:
        # If location is set by lat/lon coordinates:
        node.parmTuple('latlonzoom').deleteAllKeyframes()
        node.parm('latlonzoomx').set(lat)
        node.parm('latlonzoomy').set(lon)
        node.parm('latlonzoomz').set(zoom)
        
    else:
        # If location is set by tile index X/Y:
        tile = mercantile.tile(lon, lat, int(zoom))
        node.parmTuple('xyzoom').deleteAllKeyframes()
        node.parm('xyzoomx').set(tile.x)
        node.parm('xyzoomy').set(tile.y)
        node.parm('xyzoomz').set(tile.z)

    if should_download:
        updateLocation(node)

    window.close()

    return


def precutTileCenterCoords(precut_tile):

    MAX_ZOOM_IN_USE = 22

    if precut_tile.z < MAX_ZOOM_IN_USE:
        bounds_WSEN = mercantile.bounds(mercantile.children(precut_tile)[0])
        # The top-left child tile's SE corner is used as the tile center
        lon = bounds_WSEN[2]
        lat = bounds_WSEN[1]

    else:
        bounds_WSEN = mercantile.bounds(precut_tile)
        lon = 0.5 * (bounds_WSEN[0] + bounds_WSEN[2])
        lat = 0.5 * (bounds_WSEN[1] + bounds_WSEN[3])

    return (lon, lat)


def syncLocation(node, sync_direction):

    if sync_direction == 0:
        # If it's from lat/lon to tile index X/Y:
        lat = node.parm("latlonzoomx").evalAsFloat() 
        lon = node.parm("latlonzoomy").evalAsFloat()
        zoom = node.parm("latlonzoomz").evalAsFloat()
        tile = mercantile.tile(lon, lat, int(zoom))
        node.parmTuple('xyzoom').deleteAllKeyframes()
        node.parm('xyzoomx').set(tile.x)
        node.parm('xyzoomy').set(tile.y)
        node.parm('xyzoomz').set(tile.z)

    else:
        # If it's from tile index X/Y to lat/lon:
        x = node.parm('xyzoomx').evalAsInt()
        y = node.parm('xyzoomy').evalAsInt()
        zoom = node.parm('xyzoomz').evalAsInt()
        lon, lat = precutTileCenterCoords(mercantile.Tile(x, y, zoom))
        node.parmTuple('latlonzoom').deleteAllKeyframes()
        node.parm('latlonzoomx').set(lat)
        node.parm('latlonzoomy').set(lon)
        node.parm('latlonzoomz').set(float(zoom))

    return


def downloadFile(url, filepath, should_retry=False, retry_delay=5.0, retry_limit=3, retry_count=0):
    # Returns True if the operation succeeds, otherwise returns False

    try:

        data = urlopen(url, context=ssl._create_unverified_context())
        with open(filepath, 'wb') as output:
            output.write(data.read())
            output.close()

        return True

    except HTTPError as err:

        if should_retry:
            
            if retry_count + 1 <= retry_limit:
                msg = "Attempted accessing: {0}\n".format(url)
                msg += "HTTP Error {0}: {1}. Starting retry #{2} after {3} seconds...".format(err.code, err.reason, retry_count + 1, retry_delay)
                printError(msg)
                time.sleep(retry_delay)
                downloadFile(url, filepath, True, retry_delay, retry_limit, retry_count + 1)

            else:
                msg = "HTTP Error {0}: {1}. Retry Limit is reached.".format(err.code, err.reason)
                printError(msg, should_raise_error=True)

        else:

            msg = "Attempted accessing: {0}\n".format(url)
            msg += "HTTP Error {0}: {1}".format(err.code, err.reason)
            printError(msg, should_raise_error=True)

        return False


def subtileGrid3x3(center_subtile):
    # Returns an empty list if the operation fails

    center_x = center_subtile.x
    center_y = center_subtile.y
    zoom = center_subtile.z
    highest_index = (2 ** zoom) - 1
    width = highest_index + 1

    if center_x < 0 or center_x > highest_index:
        msg = "Unexpected Error: Center subtile's X index {0} is invalid.".format(center_x)
        printError(msg, should_raise_error=True)
        return []
    if center_y < 0 or center_y > highest_index:
        msg = "Unexpected Error: Center subtile's Y index {0} is invalid.".format(center_y)
        printError(msg, should_raise_error=True)
        return []
    if center_y == 0 or center_y == highest_index:
        msg = "Location is too close to the northern or southern limit to generate a full tile at this Zoom level."
        printError(msg, should_raise_error=True)
        return []

    grid = []
    # Order: top-left, top-middle, top-right, center-left, center-middle, center-right, bottom-left, bottom-middle, bottom-right
    grid.append(mercantile.Tile((center_x - 1) % width, center_y - 1, zoom))
    grid.append(mercantile.Tile(center_x, center_y - 1, zoom))
    grid.append(mercantile.Tile((center_x + 1) % width, center_y - 1, zoom))
    grid.append(mercantile.Tile((center_x - 1) % width, center_y, zoom))
    grid.append(center_subtile)
    grid.append(mercantile.Tile((center_x + 1) % width, center_y, zoom))
    grid.append(mercantile.Tile((center_x - 1) % width, center_y + 1, zoom))
    grid.append(mercantile.Tile(center_x, center_y + 1, zoom))
    grid.append(mercantile.Tile((center_x + 1) % width, center_y + 1, zoom))

    return grid


def setTileBounds(node, precut_tile=None, longitude=0, latitude=0, zoom=0, offset_x=0, offset_y=0):

    # All offsets are expected to be validated and processed before this function is called
    # so that the output tile bounds will always be within the correct ranges

    # Computes bounds and center
    if precut_tile:
        # If it's a precut tile:

        bound_W, bound_S, bound_E, bound_N = mercantile.bounds(precut_tile)
        center_lon, center_lat = precutTileCenterCoords(precut_tile)

    else:
        # If it's a centered tile:

        MAX_ZOOM = 28  
        # https://github.com/mapbox/mercantile/blob/main/mercantile/__init__.py
        # On the equator, a tile's width is 0.14929107086948487 m at zoom 28

        # The number of smallest tiles needed to match half the width of the final tile
        center_to_corner_offset = (2 ** max(0, MAX_ZOOM - zoom)) / 2

        # Gets the smallest tile (a tile at the max zoom level) that contains the lat/lon pin
        min_container_tile = mercantile.tile(longitude, latitude, MAX_ZOOM)
        # Computes lat/lon pin's relative UV position within the minimum container tile
        bounds_WSEN = mercantile.bounds(min_container_tile)
        min_rel_u = (longitude - bounds_WSEN[0]) / (bounds_WSEN[2] - bounds_WSEN[0])
        min_rel_v = (bounds_WSEN[3] - latitude) / (bounds_WSEN[3] - bounds_WSEN[1])

        # Gets the smallest tile that contains the SW corner of the final tile
        tile_x = min_container_tile.x + center_to_corner_offset * (2 * offset_x - 1)
        tile_y = min_container_tile.y + center_to_corner_offset * (2 * offset_y + 1)
        SW_tile = mercantile.Tile(tile_x, tile_y, MAX_ZOOM)
        # Gets the smallest tile that contains the NE corner of the final tile
        tile_x = min_container_tile.x + center_to_corner_offset * (2 * offset_x + 1)
        tile_y = min_container_tile.y + center_to_corner_offset * (2 * offset_y - 1)
        NE_tile = mercantile.Tile(tile_x, tile_y, MAX_ZOOM)

        # Interpolates the SW corner's longitude and latitude
        bounds_WSEN = mercantile.bounds(SW_tile)
        SW_lon = min_rel_u * (bounds_WSEN[2] - bounds_WSEN[0]) + bounds_WSEN[0]
        SW_lat = bounds_WSEN[3] - min_rel_v * (bounds_WSEN[3] - bounds_WSEN[1])
        # Interpolates the NE corner's longitude and latitude
        bounds_WSEN = mercantile.bounds(NE_tile)
        NE_lon = min_rel_u * (bounds_WSEN[2] - bounds_WSEN[0]) + bounds_WSEN[0]
        NE_lat = bounds_WSEN[3] - min_rel_v * (bounds_WSEN[3] - bounds_WSEN[1])

        # Gets the final tile center's longitude and latitude
        if offset_x == 0 and offset_y == 0:
            center_lon = longitude
            center_lat = latitude

        else:
            # Gets the smallest tile that contains the center of the final tile
            tile_x = min_container_tile.x + center_to_corner_offset * (2 * offset_x)
            tile_y = min_container_tile.y + center_to_corner_offset * (2 * offset_y)
            C_tile = mercantile.Tile(tile_x, tile_y, MAX_ZOOM)
            # Interpolates the final tile center's longitude and latitude
            bounds_WSEN = mercantile.bounds(C_tile)
            center_lon = min_rel_u * (bounds_WSEN[2] - bounds_WSEN[0]) + bounds_WSEN[0]
            center_lat = bounds_WSEN[3] - min_rel_v * (bounds_WSEN[3] - bounds_WSEN[1])

        bound_W = SW_lon
        bound_S = SW_lat
        bound_E = NE_lon
        bound_N = NE_lat

    # Sets bounds and center
    node.parmTuple('bounds').deleteAllKeyframes()
    node.parm('bounds1').set(bound_W)
    node.parm('bounds2').set(bound_S)
    node.parm('bounds3').set(bound_E)
    node.parm('bounds4').set(bound_N)
    node.parmTuple('centerlatlon').deleteAllKeyframes()
    node.parm('centerlatlon1').set(center_lat)
    node.parm('centerlatlon2').set(center_lon)

    return (bound_W, bound_S, bound_E, bound_N, center_lon, center_lat)


def circumference(latitude):

    # WGS 84 equatorial radius (semi-major axis): https://en.wikipedia.org/wiki/World_Geodetic_System
    a = 6378137.0  # Metres
    # WGS 84 polar radius (semi-minor axis)
    b = 6356752.314245  # Metres

    # Geodetic latitude (in radians)
    phi = radians(abs(latitude))
    # Geocentric radius: https://en.wikipedia.org/wiki/Earth_radius
    r = sqrt(((a * a * cos(phi)) ** 2 + (b * b * sin(phi)) ** 2) / ((a * cos(phi)) ** 2 + (b * sin(phi)) ** 2))
    # Geocentric latitude (in radians): https://en.wikipedia.org/wiki/Latitude#Geocentric_latitude
    theta = atan(((b / a) ** 2) * tan(phi))
    # Distance from the minor axis
    r_minor = r * sin(0.5 * pi - theta)
    # Circumference at latitude
    c = 2.0 * pi * r_minor

    return c


def realWorldTileWidth(reference_latitude, zoom):

    return circumference(reference_latitude) / (2 ** max(0, zoom))


def calcWidth(node):

    node.parm('calc_outwidth').deleteAllKeyframes()
    node.parm('calc_outwidth').set(realWorldTileWidth(node.parm('calc_inlat').evalAsFloat(), node.parm('calc_inzoom').evalAsInt()))

    return


def updateLocationInternal(node, should_download=True):
    
    if should_download:

        # Gets Mapbox tokens
        ACCESS_TOKEN = getAPIAccessToken(node)
        SKU_TOKEN = getSKUToken(node)

        # Turns off materials and point color sampling to 
        # prevent issues related to out-of-date textures.
        # Manually turning them on after downloads guarantees 
        # that better safety checks can be enforced.
        disableAllColors(node)

        # Gets download settings
        is_including_color = isIncludingColor(node)
        is_including_elevation = isIncludingElevation(node)
        style_option = node.parm("mapstyle").evalAsString()
        temp_dir = node.parm('tempdir').evalAsString()
        should_retry = node.parm('allowdownloadretry').evalAsInt()
        retry_delay_map = node.parm('retrydelay').evalAsFloat()
        retry_limit = node.parm('retrylimit').evalAsInt()
        if not is_including_color and not is_including_elevation:
            msg = "No map is selected."
            printError(msg)

    # Gets location settings

    is_using_lat_lon = node.parm('locmode').evalAsInt() == 0
    is_centered = is_using_lat_lon and node.parm('alignmode').evalAsInt() == 0

    if is_using_lat_lon:
        lat = node.parm("latlonzoomx").evalAsFloat() 
        lon = node.parm("latlonzoomy").evalAsFloat()
        zoom = int(node.parm("latlonzoomz").evalAsFloat())
    else:
        x = node.parm('xyzoomx').evalAsInt()
        y = node.parm('xyzoomy').evalAsInt()
        zoom = node.parm('xyzoomz').evalAsInt()

    offset_x = node.parm("offsetsx").evalAsInt()
    offset_y = node.parm("offsetsy").evalAsInt()
    has_offset = offset_x != 0 or offset_y != 0

    # Checks zoom level validity

    # Mapbox Static Tiles API supports zoom level 0-22.
    # mapbox.mapbox-terrain-dem-v1 tileset supports zoom level 0-14.
    # In either case, the highest zoom level Mapbox SOP supports is one level lower (i.e. 21, 13),
    # because we need to composite a tile from 4 or 9 subtiles to get a higher image resolution.
    # If the tile is centered at the lat/lon pin, it requires 9 subtiles instead of 4 subtiles,
    # in which case, the zoom level has to start at 1 because zoom level 0 only has 4 subtiles.
    zoom_min = 1 if is_centered else 0
    zoom_max = 13 if isIncludingElevation(node) else 21
    if zoom < zoom_min or zoom > zoom_max:
        msg = "Zoom level is outside the currently supported range: {0}-{1}.".format(zoom_min, zoom_max)
        printError(msg, should_raise_error=True)
        return

    # Checks lat/lon or tile index X/Y validity
    if is_using_lat_lon:
        if lat < -85.0511 or lat > 85.0511:  # More precisely: -/+ arctan(sinh(π))
            msg = "Latitude should be between -85.0511 and 85.0511."
            printError(msg, should_raise_error=True)
            return
        if lon < -180.0 or lon > 180.0:  # The mercantile module treats -180 and 180 differently
            msg = "Longitude should be between -180.0 and 180.0."
            printError(msg, should_raise_error=True)
            return

    else:
        highest_index = (2 ** zoom) - 1
        if x < 0 or x > highest_index or y < 0 or y > highest_index:
            msg = "At Zoom level {0}, both Tile Index X and Y should be between 0 and {1}.".format(zoom, highest_index)
            printError(msg, should_raise_error=True)
            return
    
    # Gets all subtiles required to composite the final tile and gets final tile bounds
    subtiles = []
    if is_centered:
        # If it's a centered tile:

        # Subtiles are one zoom level higher than the final tile
        center_subtile = mercantile.tile(lon, lat, zoom + 1)

        center_x = center_subtile.x
        center_y = center_subtile.y
        center_z = center_subtile.z
        highest_index = (2 ** center_z) - 1
        width = highest_index + 1

        if center_y == 0 or center_y == highest_index:
            msg = "Location is too close to the northern or southern limit to generate a full tile at this Zoom level."
            printError(msg, should_raise_error=True)
            return

        if should_download:
            # Computes lat/lon pin's relative UV position within the center subtile
            bounds_WSEN = mercantile.bounds(center_subtile)
            node.parmTuple('pinrelpos').deleteAllKeyframes()
            node.parm('pinrelposx').set((lon - bounds_WSEN[0]) / (bounds_WSEN[2] - bounds_WSEN[0]))
            node.parm('pinrelposy').set((bounds_WSEN[3] - lat) / (bounds_WSEN[3] - bounds_WSEN[1]))

        # Applies offset to the center subtile
        if has_offset:

            center_x += offset_x * 2  # The multiplier 2 converts final tile offsets to subtile offsets
            center_x %= width
            center_y += offset_y * 2

            # Center subtile must be one subtile away from a border subtile
            if center_y <= 0:
                msg = "Tile Offset Y is pushing the tile beyond the northern limit."
                printError(msg, should_raise_error=True)
                return

            elif center_y >= highest_index:
                msg = "Tile Offset Y is pushing the tile beyond the southern limit."
                printError(msg, should_raise_error=True)
                return

            if should_download:
                center_subtile = mercantile.Tile(center_x, center_y, center_z)

        # Sets tile bounds
        bounds_WSENCC = setTileBounds(node, longitude=lon, latitude=lat, zoom=zoom, offset_x=offset_x, offset_y=offset_y)
        bound_W = bounds_WSENCC[0]
        bound_S = bounds_WSENCC[1]
        bound_E = bounds_WSENCC[2]
        bound_N = bounds_WSENCC[3]
        center_lat = bounds_WSENCC[5]

        # Gets neighbour subtiles and builds a row-first 3×3 grid as a list
        if should_download:
            subtiles = subtileGrid3x3(center_subtile)
            subtile_count = len(subtiles)
            if subtile_count == 0:
                # In this case, the errors are raised by subtileGrid3x3()
                return
            elif subtile_count != 9:
                msg = "Unexpected Error: Subtile count is incorrect. It should be 9, but it is {}.".format(subtile_count)
                printError(msg, should_raise_error=True)
                return

    else:
        # If it's a precut tile:

        if is_using_lat_lon:
            tile = mercantile.tile(lon, lat, zoom)
        else:
            tile = mercantile.Tile(x, y, zoom)

        tile_x = tile.x
        tile_y = tile.y
        tile_z = tile.z
        highest_index = (2 ** tile_z) - 1
        width = highest_index + 1

        # Applies offset to the tile
        if has_offset:

            tile_x += offset_x
            tile_x %= width
            tile_y += offset_y

            if tile_y < 0:
                msg = "Tile Offset Y is pushing the tile beyond the northern limit."
                printError(msg, should_raise_error=True)
                return

            elif tile_y > highest_index:
                msg = "Tile Offset Y is pushing the tile beyond the southern limit."
                printError(msg, should_raise_error=True)
                return

            tile = mercantile.Tile(tile_x, tile_y, tile_z)

        # Sets tile bounds
        bounds_WSENCC = setTileBounds(node, precut_tile=tile)
        bound_W = bounds_WSENCC[0]
        bound_S = bounds_WSENCC[1]
        bound_E = bounds_WSENCC[2]
        bound_N = bounds_WSENCC[3]
        center_lat = bounds_WSENCC[5]

        # Gets child subtiles and builds a row-first 2×2 grid as a list
        if should_download:
            children = mercantile.children(tile)
            subtiles.append(children[0])
            subtiles.append(children[1])
            subtiles.append(children[3])
            subtiles.append(children[2])

    # Sets real-world tile widths
    node.parmTuple('realwidth').deleteAllKeyframes()
    node.parm('realwidth1').set(realWorldTileWidth(bound_N, zoom))
    node.parm('realwidth2').set(realWorldTileWidth(center_lat, zoom))
    node.parm('realwidth3').set(realWorldTileWidth(bound_S, zoom))

    # Downloads and composites maps
    if should_download:

        # Downloads maps of all subtiles
        for i in range(len(subtiles)):

            x = int(subtiles[i].x)
            y = int(subtiles[i].y)
            z = int(subtiles[i].z)

            # Downloads color map
            if is_including_color:
        
                if style_option != "custom":
                    mapstyle = "mapbox/" + style_option
                else:
                    mapstyle = node.parm("customstyle").evalAsString().replace("mapbox://styles/", "")
        
                # Mapbox Static Tiles API
                color_url = "https://api.mapbox.com/styles/v1/{0}/tiles/512/{1}/{2}/{3}@2x?access_token={4}".format(mapstyle, z, x, y, ACCESS_TOKEN)
    
                # Mapbox Raster Tiles API
                # Mapbox Static Tiles API is used instead because it has better map style options
        
                # Mapbox Static Images API
                # Mapbox Static/Raster Tiles APIs are preferred because they use tile X/Y indices and the elevation APIs only use X/Y indices
                #color_url = "https://api.mapbox.com/styles/v1/" + mapstyle + "/static/" + str(lon) + "," + str(lat) + "," + str((zoom)) + "/1024x1024@2x?access_token="+ ACCESS_TOKEN + "&attribution=" + cached_attribution + "&logo=false"
        
                color_path = temp_dir + 'color_{0}.jpg'.format(i)
                color_dir = os.path.dirname(color_path)
                if not os.path.exists(color_dir):
                    os.makedirs(color_dir)
                success = downloadFile(color_url, color_path, should_retry, retry_delay_map, retry_limit)
                if not success:
                    return
        
            # Downloads elevation map
            if is_including_elevation:
        
                # mapbox.mapbox-terrain-dem-v1 tileset
                terrain_url = "https://api.mapbox.com/raster/v1/mapbox.mapbox-terrain-dem-v1/{0}/{1}/{2}.png?sku={3}&access_token={4}".format(z, x, y, SKU_TOKEN, ACCESS_TOKEN)
                
                # mapbox.terrain-rgb tileset
                # mapbox.mapbox-terrain-dem-v1 is recommended by Mapbox as they will no longer update mapbox.terrain-rgb
                #terrain_url = "https://api.mapbox.com/v4/mapbox.terrain-rgb/{0}/{1}/{2}.pngraw?access_token={3}".format(z, x, y, ACCESS_TOKEN)

                terrain_path = temp_dir + 'elevation_{0}.png'.format(i)
                terrain_dir = os.path.dirname(terrain_path)
                if not os.path.exists(terrain_dir):
                    os.makedirs(terrain_dir)
                success = downloadFile(terrain_url, terrain_path, should_retry, retry_delay_map, retry_limit)
                if not success:
                    return

        # Forces composite network cache to update
        hou.hscript("compfree -c")
        hou.hscript("compfree -d")

        # Composites elevation map
        if is_including_elevation:
            elevation_path = node.parm('filepath_elev').evalAsString()
            if os.path.isfile(elevation_path):
                os.remove(elevation_path)
            node.node('cop_downloaded_elevation/sub_maps_msg').parm('reload').pressButton()
            time.sleep(1)
            node.node("cop_downloaded_elevation/RENDER").render()
            node.node('cop_elevation/map_msg').parm('reload').pressButton()

        # Composites color map
        if is_including_color:
            color_path = node.parm('filepath_color').evalAsString()
            if os.path.isfile(color_path):
                os.remove(color_path)
            node.node('cop_downloaded_color/sub_maps_msg').parm('reload').pressButton()
            time.sleep(1)
            node.node('cop_downloaded_color/RENDER').render()
            node.node('cop_color/map_msg').parm('reload').pressButton()

        # Deletes the temp subtile folder and the images inside.
        # Each Mapbox SOP has its own temp subtile folder.
        if node.parm('autodeltemp').evalAsInt() and os.path.exists(temp_dir):
            from shutil import rmtree
            rmtree(temp_dir)

        # Sets the node's mode to cook outputs
        node.parm('mode').deleteAllKeyframes()
        node.parm('mode').set(1)

    return


def updateLocation(node, should_download=True):

    # Suppresses the occasional incorrect warnings(FutureWarnings) raised by the mercantile module
    with warnings.catch_warnings():
        warnings.filterwarnings("ignore", category=FutureWarning, module='mercantile')
        updateLocationInternal(node, should_download)

    return


def launchMap(node):

    win = QtWidgets.QWidget()
    win.setWindowTitle('Mapbox - Set Location')
    win_size_x = node.parm('mapwinsizex').evalAsFloat()
    win_size_y = node.parm('mapwinsizey').evalAsFloat()
    win.setMinimumSize(win_size_x, win_size_y)
    win.setMaximumSize(win_size_x, win_size_y)
    layout = QtWidgets.QVBoxLayout()
    win.setLayout(layout)
    web_view = QtWebEngineWidgets.QWebEngineView()

    if node.parm('locmode').evalAsInt() == 0:
        # If location is set by lat/lon coordinates:
        lat = node.parm('latlonzoomx').evalAsFloat()
        lon = node.parm('latlonzoomy').evalAsFloat()
        zoom = node.parm('latlonzoomz').evalAsFloat()
    else:
        # If location is set by tile index X/Y:
        x = node.parm('xyzoomx').evalAsInt()
        y = node.parm('xyzoomy').evalAsInt()
        zoom = node.parm('xyzoomz').evalAsInt()
        center_coords = precutTileCenterCoords(mercantile.Tile(x, y, zoom))
        lon = center_coords[0]
        lat = center_coords[1]
        zoom = float(zoom)

    # As of Mapbox GL JS v2.15.0, the interactive map cannot launch at zoom level 0 correctly.
    # Forcing zoom level to be -1 is a hack that can correct the issue. 
    # This hack is safe because when setting the actual location for downloads, 
    # any negative zoom levels are forced to be 0.
    if zoom <= 0.0:
        lon = lat = 0.0
        zoom = -1.0

    if isIncludingElevation(node) and node.parm('skutoken').evalAsString() == '':
        # If a new SKU token is required:
        html_file = 'mapbox-map-sku.html'
    else:
        # If a new SKU token is not required:
        html_file = 'mapbox-map.html'

    url = os.environ["HOUDINI_USER_PREF_DIR"] + "/SideFXLabs/misc/mapbox/{0}?#{1},{2},{3},".format(html_file, lon, lat, zoom) + getAPIAccessToken(node)

    if platform.system() != "Windows":
        url = "file://" + url
        
    web_view.setUrl(url)
    layout.addWidget(web_view)

    button = QtWidgets.QPushButton("Set Location Only")
    button.clicked.connect(lambda: onButton(node, web_view, win, False))
    layout.addWidget(button)
    
    button = QtWidgets.QPushButton("Set Location and Download")
    button.clicked.connect(lambda: onButton(node, web_view, win, True))
    layout.addWidget(button)
    
    win.show()

    return


def viewPrecutTile(node):

    win = QtWidgets.QWidget()
    win.setWindowTitle('Mapbox - Precut Tile')
    win_size_x = node.parm('mapwinsizex').evalAsFloat()
    win_size_y = node.parm('mapwinsizey').evalAsFloat() - 35
    win_size_y = max(70, win_size_y)
    win.setMinimumSize(win_size_x, win_size_y)
    win.setMaximumSize(win_size_x, win_size_y)
    layout = QtWidgets.QVBoxLayout()
    win.setLayout(layout)
    web_view = QtWebEngineWidgets.QWebEngineView()

    lat = node.parm('latlonzoomx').evalAsFloat()
    lon = node.parm('latlonzoomy').evalAsFloat()
    zoom = node.parm('latlonzoomz').evalAsFloat()
    if zoom > 0:
        center_coords = precutTileCenterCoords(mercantile.tile(lon, lat, int(zoom)))
        lon = center_coords[0]
        lat = center_coords[1]

    # As of Mapbox GL JS v2.15.0, the interactive map cannot launch at zoom level 0 correctly.
    # Forcing zoom level to be -1 is a hack that can correct the issue. 
    # This hack is safe because when setting the actual location for downloads, 
    # any negative zoom levels are forced to be 0.
    if zoom <= 0.0:
        lon = lat = 0.0
        zoom = -1.0

    html_file = 'mapbox-map.html'

    url = os.environ["HOUDINI_USER_PREF_DIR"] + "/SideFXLabs/misc/mapbox/{0}?#{1},{2},{3},".format(html_file, lon, lat, zoom) + getAPIAccessToken(node)

    try:

        if platform.system() != "Windows":
            url = "file://" + url
        
        web_view.setUrl(url)
        layout.addWidget(web_view)

        button = QtWidgets.QPushButton("Close")
        button.clicked.connect(lambda: win.close())
        layout.addWidget(button)

        win.show()

    except Exception as exc:
        
        print (type(exc).__name__, exc)

    return


def refreshSKUToken(node):

    win = QtWidgets.QWidget()
    win.setWindowTitle('Mapbox - Refresh SKU Token')
    win.setMinimumSize(500, 70)
    win.setMaximumSize(500, 70)
    layout = QtWidgets.QVBoxLayout()
    win.setLayout(layout)
    web_view = QtWebEngineWidgets.QWebEngineView()

    url = os.environ["HOUDINI_USER_PREF_DIR"] + "/SideFXLabs/misc/mapbox/mapbox-sku.html?#0,0,0," + getAPIAccessToken(node)

    try:
        
        if platform.system() != "Windows":
            url = "file://" + url
            
        web_view.setUrl(url)
        layout.addWidget(web_view)
        web_view.setVisible(False)
        
        button = QtWidgets.QPushButton("Get New SKU Token")
        button.clicked.connect(lambda: onButtonSKU(node, web_view, win))
        button.resize(400, 55)
        layout.addWidget(button)

        win.show()

    except Exception as exc:
        
        print (type(exc).__name__, exc)

    return
